//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.4

use crate::models::{
    default_models::{
        block_metadata_transactions::BlockMetadataTransactionModel, transactions::TransactionModel,
    },
    user_transactions_models::user_transactions::UserTransactionModel,
};
use aptos_protos::{
    transaction::v1::{
        transaction::TxnData, transaction_payload::Type, write_set::WriteSetType,
        Transaction as TransactionPB,
    },
    util::timestamp::Timestamp,
};
use rust_decimal::Decimal;
use sea_orm::entity::prelude::*;
use std::str::FromStr;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Default)]
#[sea_orm(table_name = "transactions")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub transaction_version: String,
    pub transaction_block_height: i64,
    pub hash: String,
    pub transaction_type: String,
    #[sea_orm(column_type = "JsonBinary", nullable)]
    pub payload: Option<Json>,
    pub payload_type: Option<String>,
    pub state_change_hash: String,
    pub event_root_hash: String,
    pub state_checkpoint_hash: Option<String>,
    pub gas_used: Decimal,
    pub success: bool,
    pub vm_status: String,
    pub accumulator_root_hash: String,
    pub num_events: i64,
    pub num_write_set_changes: i64,
    pub epoch: i64,
    pub parent_signature_type: Option<String>,
    pub sender: Option<String>,
    pub sequence_number: Option<i64>,
    pub max_gas_amount: Option<Decimal>,
    pub expiration_timestamp_secs: Option<DateTime>,
    pub gas_unit_price: Option<Decimal>,
    pub timestamp: Option<DateTime>,
    pub entry_function_id_str: Option<String>,
    #[sea_orm(column_type = "JsonBinary", nullable)]
    pub signature: Option<Json>,
    pub id: Option<String>,
    pub round: Option<i64>,
    #[sea_orm(column_type = "JsonBinary", nullable)]
    pub previous_block_votes_bitvec: Option<Json>,
    pub proposer: Option<String>,
    #[sea_orm(column_type = "JsonBinary", nullable)]
    pub failed_proposer_indices: Option<Json>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

impl ActiveModel {
    pub fn from_transactions(transactions: Vec<TransactionPB>) -> Vec<Self> {
        let mut transactions_to_return = vec![];
        for transaction in transactions {
            let (txn, blockmetadata_txn, _, _) = TransactionModel::from_transaction(&transaction);
            let txn_data = transaction
                .txn_data
                .as_ref()
                .expect("Txn Data doesn't exit!");
            let timestamp = &transaction.timestamp.as_ref().unwrap();
            transactions_to_return
                .push(Self::transaction_to_insert(txn, txn_data, blockmetadata_txn, timestamp));
        }
        transactions_to_return
    }

    fn transaction_to_insert(
        txn: TransactionModel,
        txn_detail: &TxnData,
        blockmetadata_txn: Option<BlockMetadataTransactionModel>,
        timestamp: &Timestamp,
    ) -> Self {
        let mut transaction = ActiveModel {
            transaction_version: sea_orm::ActiveValue::Set(txn.version.to_string()),
            transaction_block_height: sea_orm::ActiveValue::Set(txn.block_height),
            hash: sea_orm::ActiveValue::Set(txn.hash),
            transaction_type: sea_orm::ActiveValue::Set(txn.type_),
            payload: sea_orm::ActiveValue::Set(Some(serde_json::to_value(&txn.payload).unwrap())),
            state_change_hash: sea_orm::ActiveValue::Set(txn.state_change_hash),
            event_root_hash: sea_orm::ActiveValue::Set(txn.event_root_hash),
            state_checkpoint_hash: sea_orm::ActiveValue::Set(txn.state_checkpoint_hash),
            success: sea_orm::ActiveValue::Set(txn.success),
            vm_status: sea_orm::ActiveValue::Set(txn.vm_status),
            accumulator_root_hash: sea_orm::ActiveValue::Set(txn.accumulator_root_hash),
            gas_used: sea_orm::ActiveValue::Set(
                Decimal::from_str(&txn.gas_used.to_string()).unwrap_or(Decimal::ZERO),
            ),
            epoch: sea_orm::ActiveValue::Set(txn.epoch),
            ..<Self as std::default::Default>::default()
        };

        match txn_detail {
            TxnData::User(inner) => {
                let (user_transaction, sigs) = UserTransactionModel::from_transaction(
                    inner,
                    timestamp,
                    txn.block_height,
                    txn.epoch,
                    txn.version,
                );
                transaction.parent_signature_type =
                    sea_orm::ActiveValue::Set(Some(user_transaction.parent_signature_type));
                transaction.sender = sea_orm::ActiveValue::Set(Some(user_transaction.sender));
                transaction.sequence_number =
                    sea_orm::ActiveValue::Set(Some(user_transaction.sequence_number));
                transaction.expiration_timestamp_secs =
                    sea_orm::ActiveValue::Set(Some(user_transaction.expiration_timestamp_secs));
                transaction.timestamp = sea_orm::ActiveValue::Set(Some(user_transaction.timestamp));
                transaction.entry_function_id_str =
                    sea_orm::ActiveValue::Set(Some(user_transaction.entry_function_id_str));
                transaction.gas_unit_price = sea_orm::ActiveValue::Set(Some(
                    Decimal::from_str(&user_transaction.gas_unit_price.to_string())
                        .unwrap_or(Decimal::ZERO),
                ));
                transaction.max_gas_amount = sea_orm::ActiveValue::Set(Some(
                    Decimal::from_str(&user_transaction.max_gas_amount.to_string())
                        .unwrap_or(Decimal::ZERO),
                ));
                transaction.signature =
                    sea_orm::ActiveValue::Set(Some(serde_json::to_value(sigs).unwrap()));
                let payload = inner
                    .request
                    .as_ref()
                    .expect("Getting user request failed.")
                    .payload
                    .as_ref()
                    .expect("Getting payload failed.");
                transaction.payload_type = sea_orm::ActiveValue::Set(Some(
                    Type::try_from(payload.r#type)
                        .expect("Payload type doesn't exist!")
                        .as_str_name()
                        .to_string(),
                ));
            },
            TxnData::BlockMetadata(_) if blockmetadata_txn.is_some() => {
                let blockmetadata_txn = blockmetadata_txn.unwrap();
                transaction.id = sea_orm::ActiveValue::Set(Some(blockmetadata_txn.id));
                transaction.round = sea_orm::ActiveValue::Set(Some(blockmetadata_txn.round));
                let previous_block_votes_bitvec =
                    serde_json::to_string(&blockmetadata_txn.previous_block_votes_bitvec)
                        .unwrap_or_default();
                transaction.previous_block_votes_bitvec = sea_orm::ActiveValue::Set(
                    Some(serde_json::Value::String(previous_block_votes_bitvec))
                );
                transaction.proposer = sea_orm::ActiveValue::Set(Some(blockmetadata_txn.proposer));
            },
            TxnData::Genesis(inner) => {
                let payload = inner.payload.as_ref().unwrap();
                transaction.payload_type = sea_orm::ActiveValue::Set(Some(
                    WriteSetType::try_from(payload.write_set_type)
                        .expect("WriteSet type doesn't exist!")
                        .as_str_name()
                        .to_string(),
                ));
            },
            _ => {},
        }

        transaction
    }
}
